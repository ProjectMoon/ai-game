use std::fmt::Display;

use serde::{Deserialize, Serialize};
use strum::{EnumString, EnumVariantNames};
use thiserror::Error;

/// Stored in the database to bypass AI 'parsing' when possible.
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct CachedParsedCommand {
    pub raw: String,
    pub scene_key: String,
    pub commands: ParsedCommands,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct ParsedCommands {
    #[serde(default)]
    pub original: String, // The original text entered by the player, set by code.
    pub commands: Vec<ParsedCommand>,
    pub count: usize,
}

impl ParsedCommands {
    pub fn single(original: &str, cmd: ParsedCommand) -> ParsedCommands {
        ParsedCommands {
            original: original.to_owned(),
            commands: vec![cmd],
            count: 1,
        }
    }
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct ParsedCommand {
    pub verb: String,
    pub target: String,
    pub location: String,
    pub using: String,
}

#[derive(Deserialize, Debug, Clone)]
pub struct VerbsResponse {
    pub verbs: Vec<String>,
}

#[derive(Deserialize, Debug, Clone)]
pub struct VerbsAndTargets {
    pub entries: Vec<VerbAndTargetEntry>,
}

#[derive(Deserialize, Debug, Clone)]
pub struct VerbAndTargetEntry {
    pub verb: String,
    pub target: String,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct RawCommandExecution {
    pub valid: bool,
    pub reason: Option<String>,
    pub narration: String,
    pub events: Vec<RawCommandEvent>,
}

impl RawCommandExecution {
    pub fn empty() -> RawCommandExecution {
        RawCommandExecution {
            valid: true,
            reason: None,
            narration: "".to_string(),
            events: vec![],
        }
    }
}

#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct RawCommandEvent {
    pub event_name: String,
    pub applies_to: String,
    pub parameter: String,
}

#[derive(Debug, Serialize, Deserialize, Clone, EnumString, EnumVariantNames)]
#[strum(serialize_all = "snake_case")]
#[serde(rename_all = "snake_case")]
pub enum CommandEvent {
    // Informational
    Narration(String),
    LookAtEntity {
        entity_key: String,
        scene_key: String,
    },

    // Movement-related
    ChangeScene {
        scene_key: String,
    },

    // Player character state
    TakeDamage {
        target: String,
        amount: u32,
    },
    Stand {
        target: String,
    },
    Sit {
        target: String,
    },
    Prone {
        target: String,
    },
    Crouch {
        target: String,
    },
    Unrecognized {
        event_name: String,
        narration: String,
    },
}

/// A builtin command has more immediate access to necessary
/// information, so we can be a bit more loose with what we give it. A
/// builtin command is only created directly via checking for builtin
/// commands. These commands may have little or no parameters, as they
/// are meant for simple, direct commands like looking, movement, etc.
#[derive(Debug)]
pub enum BuiltinCommand {
    LookAtScene,
}

#[derive(Debug)]
pub enum CommandExecution {
    Builtin(BuiltinCommand),
    AiCommand(AiCommand),
}

/// An "AI Command" is a command execution generated by the LLM and
/// run through coherence validation/fixing, and (assuming it is
/// valid) contains a series of events to apply to the game state.
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct AiCommand {
    pub valid: bool,
    pub reason: Option<String>,
    pub narration: String,
    pub events: Vec<CommandEvent>,
}

impl AiCommand {
    pub fn empty() -> AiCommand {
        AiCommand {
            valid: true,
            reason: None,
            narration: "".to_string(),
            events: vec![],
        }
    }

    pub fn from_raw_invalid(raw: RawCommandExecution) -> AiCommand {
        AiCommand {
            valid: raw.valid,
            reason: raw.reason,
            narration: "".to_string(),
            events: vec![],
        }
    }

    pub fn from_events(events: Vec<CommandEvent>) -> AiCommand {
        AiCommand {
            valid: true,
            reason: None,
            narration: "".to_string(),
            events,
        }
    }
}

#[derive(Clone, Debug)]
pub enum ExecutionConversionResult {
    Success(AiCommand),
    PartialSuccess(AiCommand, EventConversionFailures),
    Failure(EventConversionFailures),
}

impl Display for ExecutionConversionResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{:?}", self)
    }
}

#[derive(Error, Clone, Debug)]
pub struct EventConversionFailures {
    pub conversion_failures: Vec<EventConversionError>,
    pub coherence_failures: Vec<EventCoherenceFailure>,
}

impl EventConversionFailures {
    pub fn from_failures(
        conversion_failures: Vec<EventConversionError>,
        coherence_failures: Vec<EventCoherenceFailure>,
    ) -> EventConversionFailures {
        EventConversionFailures {
            conversion_failures,
            coherence_failures,
        }
    }
}

impl From<Vec<EventCoherenceFailure>> for EventConversionFailures {
    fn from(value: Vec<EventCoherenceFailure>) -> Self {
        EventConversionFailures {
            coherence_failures: value,
            conversion_failures: vec![],
        }
    }
}

impl Display for EventConversionFailures {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{:?}", self)
    }
}

#[derive(Error, Clone, Debug)]
pub enum EventConversionError {
    #[error("invalid parameter for {0:?}")]
    InvalidParameter(RawCommandEvent),

    #[error("unrecognized event - {0:?}")]
    UnrecognizedEvent(RawCommandEvent),
}

#[derive(Error, Clone, Debug)]
pub enum EventCoherenceFailure {
    #[error("target of command does not exist")]
    TargetDoesNotExist(CommandEvent),

    #[error("uncategorized coherence failure: {1}")]
    OtherError(CommandEvent, String),
}

impl EventCoherenceFailure {
    /// Consume self to extract the CommandEvent wrapped in this enum.
    pub fn as_event(self) -> CommandEvent {
        match self {
            EventCoherenceFailure::OtherError(event, _) => event,
            Self::TargetDoesNotExist(event) => event,
        }
    }
}

impl From<EventCoherenceFailure> for CommandEvent {
    fn from(value: EventCoherenceFailure) -> Self {
        value.as_event()
    }
}
