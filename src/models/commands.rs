use serde::{Deserialize, Serialize};
use strum::{EnumString, EnumVariantNames};
use thiserror::Error;

use super::world::scenes::Stage;

/// Stored in the database to bypass AI 'parsing' when possible.
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct CachedParsedCommand {
    pub raw: String,
    pub scene_key: String,
    pub commands: ParsedCommands,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct ParsedCommands {
    pub commands: Vec<ParsedCommand>,
    pub count: usize,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct ParsedCommand {
    pub verb: String,
    pub target: String,
    pub location: String,
    pub using: String,
}

#[derive(Deserialize, Debug, Clone)]
pub struct VerbsResponse {
    pub verbs: Vec<String>,
}

#[derive(Deserialize, Debug, Clone)]
pub struct VerbsAndTargets {
    pub entries: Vec<VerbAndTargetEntry>,
}

#[derive(Deserialize, Debug, Clone)]
pub struct VerbAndTargetEntry {
    pub verb: String,
    pub target: String,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct RawCommandExecution {
    pub valid: bool,
    pub reason: Option<String>,
    pub narration: String,
    pub events: Vec<RawCommandEvent>,
}

impl RawCommandExecution {
    pub fn empty() -> RawCommandExecution {
        RawCommandExecution {
            valid: true,
            reason: None,
            narration: "".to_string(),
            events: vec![],
        }
    }
}

#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct RawCommandEvent {
    pub event_name: String,
    pub applies_to: String,
    pub parameter: String,
}

#[derive(Debug, Serialize, Deserialize, Clone, EnumString, EnumVariantNames)]
#[strum(serialize_all = "snake_case")]
#[serde(rename_all = "snake_case")]
pub enum CommandEvent {
    ChangeScene {
        scene_key: String,
    },
    TakeDamage {
        target: String,
        amount: u32,
    },
    Narration(String),
    Stand {
        target: String,
    },
    Sit {
        target: String,
    },
    Prone {
        target: String,
    },
    Crouch {
        target: String,
    },
    Unrecognized {
        event_name: String,
        narration: String,
    },
}

/// A builtin command has more immediate access to necessary
/// information, so we can be a bit more loose with what we give it. A
/// builtin command is only created directly via checking for builtin
/// commands. These commands may have little or no parameters, as they
/// are meant for simple, direct commands like looking, movement, etc.
pub enum BuiltinCommand {
    Look,
}

pub enum CommandExecution {
    Builtin(BuiltinCommand),
    AiCommand(AiCommand),
}

/// An "AI Command" is a command execution generated by the LLM and
/// run through coherence validation/fixing, and (assuming it is
/// valid) contains a series of events to apply to the game state.
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct AiCommand {
    pub valid: bool,
    pub reason: Option<String>,
    pub narration: String,
    pub events: Vec<CommandEvent>,
}

impl AiCommand {
    pub fn empty() -> AiCommand {
        AiCommand {
            valid: true,
            reason: None,
            narration: "".to_string(),
            events: vec![],
        }
    }

    pub fn from_raw_invalid(raw: RawCommandExecution) -> AiCommand {
        AiCommand {
            valid: raw.valid,
            reason: raw.reason,
            narration: "".to_string(),
            events: vec![],
        }
    }
}

#[derive(Clone, Debug)]
pub enum ExecutionConversionResult {
    Success(AiCommand),
    PartialSuccess(AiCommand, EventConversionFailures),
    Failure(EventConversionFailures),
}

#[derive(Clone, Debug)]
pub struct EventConversionFailures {
    pub conversion_failures: Vec<EventConversionError>,
    pub coherence_failures: Vec<EventCoherenceFailure>,
}

impl EventConversionFailures {
    pub fn from_failures(
        conversion_failures: Vec<EventConversionError>,
        coherence_failures: Vec<EventCoherenceFailure>,
    ) -> EventConversionFailures {
        EventConversionFailures {
            conversion_failures,
            coherence_failures,
        }
    }
}

#[derive(Error, Clone, Debug)]
pub enum EventConversionError {
    #[error("invalid parameter for {0:?}")]
    InvalidParameter(RawCommandEvent),

    #[error("unrecognized event - {0:?}")]
    UnrecognizedEvent(RawCommandEvent),
}

#[derive(Error, Clone, Debug)]
pub enum EventCoherenceFailure {
    #[error("target of command does not exist")]
    TargetDoesNotExist(CommandEvent),

    #[error("uncategorized coherence failure: {1}")]
    OtherError(CommandEvent, String),
}
